# Priority Queues — Basics

## 1. Introduction
- A **Priority Queue (PQ)** is an abstract data type similar to a regular queue, but each element has a **priority**.
- Elements with **higher priority** are dequeued before elements with lower priority.
- If two elements have the same priority, they follow the **insertion order** (like a normal queue).

---

## 2. Types of Priority Queues
1. **Max Priority Queue**
   - The element with the **highest priority** is removed first.
   - Implemented using a **Max Heap**.
   
2. **Min Priority Queue**
   - The element with the **lowest priority** is removed first.
   - Implemented using a **Min Heap**.

---

## 3. Common Applications
- CPU scheduling
- Dijkstra’s shortest path algorithm
- Huffman coding
- Event-driven simulations
- Real-time data streaming (e.g., finding top-K elements)

---

## 4. Binary Heap Implementation
A **Binary Heap** is the most common structure for implementing a priority queue:
- **Min Heap**: Parent node ≤ Child nodes.
- **Max Heap**: Parent node ≥ Child nodes.
- Stored as a **complete binary tree** (all levels filled except possibly the last, filled left to right).
- Represented efficiently using an **array**.

---

### Array Representation
- **Index 0** is often unused (or root can be at 0).
- For a node at index `i`:
  - Left child: `2*i + 1` (or `2*i` if 1-based)
  - Right child: `2*i + 2` (or `2*i + 1` if 1-based)
  - Parent: `(i - 1) / 2` (or `i / 2` if 1-based)

---

## 5. Basic Operations & Complexity
| Operation           | Description                               | Time Complexity |
|---------------------|-------------------------------------------|-----------------|
| `insert(x)`         | Add element `x` and maintain heap order   | O(log n)        |
| `getTop()`          | Get min/max element                       | O(1)            |
| `extractTop()`      | Remove min/max element & heapify          | O(log n)        |
| `heapify()`         | Restore heap property                     | O(log n)        |
| `buildHeap(arr)`    | Create heap from an array                  | O(n)            |

---

## 6. Implementation Approaches
1. **Binary Heap** (most common)
2. **Balanced BST** (like Red-Black Tree)
3. **Unordered Array/List** (fast insert, slow remove)
4. **Ordered Array/List** (slow insert, fast remove)
5. **Fibonacci Heap** (used in advanced graph algorithms)

---
