## ðŸ§  PATTERN: **Heap Basics & Conversions**

---

### âœ… List of Problems
- [Does array represent Heap](https://www.geeksforgeeks.org/problems/does-array-represent-heap4345/1)
- [Convert Min Heap to Max Heap](https://www.geeksforgeeks.org/problems/convert-min-heap-to-max-heap-1666385109/1)

---

## 1) Does array represent Heap
ðŸ”— [Problem Link](https://www.geeksforgeeks.org/problems/does-array-represent-heap4345/1)

### approach 1
**Explanation:**
- A **max heap** is a complete binary tree where every node is **greater than or equal to** its children.
- The given array represents a **level-order traversal** of the heap.
- For each node `i`, check:
  - If left child exists, `arr[i] >= arr[left]`.
  - If right child exists, `arr[i] >= arr[right]`.
- If any child is greater than the parent, it's **not** a max heap.

**Steps:**
1. Loop through all elements from index `0` to `n-1`.
2. For each index `i`, calculate:
   - `left = 2 * i + 1`
   - `right = 2 * i + 2`
3. If left child index is in bounds and `arr[i] < arr[left]`, return `false`.
4. If right child index is in bounds and `arr[i] < arr[right]`, return `false`.
5. If all nodes satisfy the heap property, return `true`.

**Time Complexity:** `O(n)` (each node checked once)  
**Space Complexity:** `O(1)` (no extra space)

**Code:**
```cpp
class Solution {
  public:
    int leftChild(int i){
        return(2 * i + 1);
    }
    
    int rightChild(int i){
        return(2 * i + 2);
    }
  
    bool isMaxHeap(int arr[], int n) {
        // Your code goes here
        for(int i = 0 ; i < n ; i++){
            int left = leftChild(i);
            int right = rightChild(i);
            
            if(left >= 0 && left < n && arr[i] < arr[left]){
                return false;
            }
            if(right >= 0 && right < n && arr[i] < arr[right]){
                return false;
            }
            
        }
        
        return true;
    }
};
```

---

## 2) Convert Min Heap to Max Heap
ðŸ”— [Problem Link](https://www.geeksforgeeks.org/problems/convert-min-heap-to-max-heap-1666385109/1)

### approach 1
**Explanation:**
- A min heap follows `parent <= children`, while a max heap follows `parent >= children`.
- The conversion can be done **in-place** by:
  - Starting from the last non-leaf node `(n/2 - 1)` down to the root `0`.
  - Applying **max-heapify** (`heapifyDown`) at each node.
- `heapifyDown` compares a node with its children, swaps with the largest if needed, and recurses.

**Steps:**
1. Define helper functions:
   - `leftChild(i)` â†’ returns index `2*i + 1`
   - `rightChild(i)` â†’ returns index `2*i + 2`
2. Define `heapifyDown(arr, i, N)`:
   - Find largest among node `i`, left, and right children.
   - Swap with the largest if needed.
   - Recurse to maintain heap property.
3. In `convertMinToMaxHeap()`:
   - Loop from `(N/2 - 1)` down to `0`.
   - Call `heapifyDown` for each node.
4. After the process, the array becomes a **max heap**.

**Time Complexity:** `O(n)` (heapify for each non-leaf node)  
**Space Complexity:** `O(log n)` (recursive stack for heapify)

**Code:**
```cpp
class Solution {
  public:
    int leftChild(int i) {
        return 2 * i + 1;
    }
    
    int rightChild(int i) {
        return 2 * i + 2;
    }    
    
    void heapifyDown(vector<int> &arr, int i, int N) {
        int largest = i;
        int left = leftChild(i);
        int right = rightChild(i);
        
        if (left < N && arr[left] > arr[largest]) {
            largest = left;
        }
        if (right < N && arr[right] > arr[largest]) {
            largest = right;
        }
        
        if (largest != i) {
            swap(arr[i], arr[largest]);
            heapifyDown(arr, largest, N);
        }
    }
  
    void convertMinToMaxHeap(vector<int> &arr, int N) {
        // Start from the last non-leaf node and heapify down each node
        for (int i = N / 2 - 1; i >= 0; i--) {
            heapifyDown(arr, i, N);
        }
    }
};
```
