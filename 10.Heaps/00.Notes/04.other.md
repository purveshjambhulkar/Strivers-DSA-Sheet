## ðŸ§  PATTERN: **Heap / Priority Queue Based Problems**

---

### âœ… List of Problems

- [Connect 'n' ropes with minimal cost](https://www.geeksforgeeks.org/problems/minimum-cost-of-ropes-1587115620/1)
- [Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream)

---

## 1) Connect 'n' ropes with minimal cost
ðŸ”— [Problem Link](https://www.geeksforgeeks.org/problems/minimum-cost-of-ropes-1587115620/1)

---

### Approach 1 â€” Min-Heap Greedy

**Explanation:**
- The problem asks to connect all ropes into one rope with the **minimum total cost**.
- The cost of connecting two ropes = sum of their lengths.
- If we connect the smallest ropes first, we minimize future costs because the combined rope length will be added in subsequent operations.
- We can achieve this using a **Min Heap** (Priority Queue with smallest element on top).
- Repeatedly pick the two smallest ropes, connect them, add the cost, and push the new rope back into the heap.

**Steps:**
1. Insert all rope lengths into a min-heap.
2. Initialize `cost = 0`.
3. While heap size > 1:
   - Pop the two smallest ropes.
   - Add their sum to `cost`.
   - Push their sum back into the heap.
4. Return `cost`.

**Time Complexity:**  
- Building the heap: `O(N log N)`  
- Each pop/push operation: `O(log N)`  
- Total: `O(N log N)`

**Space Complexity:** `O(N)` for the heap.

**Code:**
```cpp
class Solution {
  public:
    int minCost(vector<int>& arr) {
        // code here
        
        if(arr.size() <= 1){
            return 0;
        }
        
        priority_queue<int , vector<int> , greater<int>> minHeap;
        
        for(int i : arr){
            minHeap.push(i);
        }
        
        int cost = 0;
        
        while(minHeap.size() != 1){
            int rope1 = minHeap.top();
            minHeap.pop();
            int rope2 = minHeap.top();
            minHeap.pop();
            
            cost += rope1 + rope2;
            
            minHeap.push(rope1 + rope2);
        }
        
        return cost;
    }
};
```

---

## 2) Find Median from Data Stream
ðŸ”— [Problem Link](https://leetcode.com/problems/find-median-from-data-stream)

---

### Approach 1 â€” Sorting after every insertion (**TLE**)

**Explanation:**
- Maintain a vector of all numbers.
- Every time we add a number, sort the vector and find the median.
- This approach is simple but inefficient for large input sizes because sorting after every insertion costs `O(N log N)`.

**Steps:**
1. Store all numbers in a vector.
2. Sort the vector after each insertion.
3. If size is odd â†’ return middle element.  
   If size is even â†’ return average of two middle elements.

**Time Complexity:**  
- Add Number: `O(N log N)` due to sorting.  
- Find Median: `O(1)`.

**Space Complexity:** `O(N)`.

**Code:**
```cpp
//Approach 1  - TLE
// vector<int> med;
//
// MedianFinder() {
//     
// }
// 
// void addNum(int num) {
//     med.push_back(num);
//     sort(med.begin() , med.end());
// }
// 
// double findMedian() {
//     int n = med.size();
//     if(n % 2 == 0){
//         int ind1 = n / 2;
//         int ind2 = ind1+1;
//         double ans = (double)(med[ind1-1] + med[ind2-1]) /2.0;
//         return ans;
//     }else {
//         int ind = (n / 2) + 1;
//         double ans = med[ind -1];
//         return ans;
//     }
// }
```

---

### Approach 2 â€” Two Heaps (Optimal)

**Explanation:**
- Maintain:
  - **Max Heap** â†’ stores the smaller half of numbers.
  - **Min Heap** â†’ stores the larger half of numbers.
- Balance the heaps so that:
  - Size difference â‰¤ 1.
  - Max Heap contains the extra element when odd total size.
- Median:
  - If heaps are equal size â†’ average of tops.
  - Else â†’ top of Max Heap.

**Steps:**
1. If number â‰¤ top of maxHeap â†’ push to maxHeap, else push to minHeap.
2. Balance sizes:
   - If maxHeap.size() > minHeap.size() + 1 â†’ move top from maxHeap to minHeap.
   - If minHeap.size() > maxHeap.size() â†’ move top from minHeap to maxHeap.
3. Median:
   - If equal sizes â†’ `(maxHeap.top() + minHeap.top()) / 2.0`.
   - Else â†’ `maxHeap.top()`.

**Time Complexity:**  
- Add Number: `O(log N)`  
- Find Median: `O(1)`

**Space Complexity:** `O(N)`

**Code:**
```cpp
class MedianFinder {
private:
    priority_queue<int> maxHeap; // stores smaller half
    priority_queue<int, vector<int>, greater<int>> minHeap; // stores larger half

public:
    MedianFinder() {
        
    }
    
    void addNum(int num) {
        if (maxHeap.empty() || num <= maxHeap.top()) {
            maxHeap.push(num);
        } else {
            minHeap.push(num);
        }
        
        // Balance the heaps
        if (maxHeap.size() > minHeap.size() + 1) {
            minHeap.push(maxHeap.top());
            maxHeap.pop();
        } else if (minHeap.size() > maxHeap.size()) {
            maxHeap.push(minHeap.top());
            minHeap.pop();
        }
    }
    
    double findMedian() {
        if (maxHeap.size() == minHeap.size()) {
            return (maxHeap.top() + minHeap.top()) / 2.0;
        } else {
            return maxHeap.top();
        }
    }
};
```
