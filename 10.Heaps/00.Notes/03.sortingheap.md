## ðŸ§  PATTERN: **Heap for Ranking & Frequency Problems**

---

### âœ… List of Problems
- [Replace Elements by its Rank in the Array](https://www.geeksforgeeks.org/problems/replace-elements-by-its-rank-in-the-array/1)
- [Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements)

---

## 1) Replace Elements by its Rank in the Array
ðŸ”— [Problem Link](https://www.geeksforgeeks.org/problems/replace-elements-by-its-rank-in-the-array/1)

### approach 1 (Sorting + Hash Map)
**Explanation:**
- Create a sorted copy of the array.
- Assign ranks to elements based on sorted order (duplicates get the same rank).
- Use a hash map to store `element -> rank`.
- Replace each element in the original array with its rank.

**Steps:**
1. Copy the original array to a temporary vector `arr1`.
2. Sort `arr1` in ascending order.
3. Initialize `rank = 1` and an unordered map `mpp`.
4. Traverse `arr1`:
   - If element is not in `mpp`, assign it the current `rank` and increment `rank`.
5. Traverse the original array:
   - Replace each element with `mpp[arr[i]]`.
6. Return the modified array.

**Time Complexity:** `O(n log n)`  
**Space Complexity:** `O(n)` (map + sorted array copy)

**Code:**
```cpp
// Approah 1 - sorting
vector<int> replaceWithRank(vector<int> &arr, int N) {
    vector<int> arr1 = arr;
    sort(arr1.begin(), arr1.end());
    int rank = 1;
    unordered_map<int , int> mpp;

    for(int i : arr1){
        if(mpp.find(i) == mpp.end()){
            mpp[i] = rank;
            rank++;
        }
    }
    
    for(int i = 0 ; i < arr.size(); i++){
        arr[i] = mpp[arr[i]];
    }
    
    return arr;
}
```

---

### approach 2 (Min Heap)
**Explanation:**
- Store each element and its original index as a pair `(value, index)` in a **min-heap**.
- Extract elements in ascending order.
- Assign ranks as elements come out of the heap:
  - Increment rank only if the current element is different from the last popped element.
- Place ranks into the original array positions using the stored index.

**Steps:**
1. Create a min-heap of pairs `(arr[i], i)` with a custom comparator for ascending order.
2. Push all elements with their indices into the heap.
3. Initialize:
   - `lastEle = INT_MAX`
   - `rank = 0`
4. While heap is not empty:
   - Pop the top element `(curr, index)`.
   - If `lastEle` is `INT_MAX` or different from `curr`, increment `rank`.
   - Set `arr[index] = rank`.
   - Update `lastEle = curr`.
5. Return the modified array.

**Time Complexity:** `O(n log n)` (heap operations for all elements)  
**Space Complexity:** `O(n)` (heap storage)

**Code:**
```cpp
vector<int> replaceWithRank(vector<int> &arr, int N) {
    // Approach 2 - using min heap
    priority_queue<pair<int ,int> , vector<pair<int ,int>>,greater<pair<int,int>>> minHeap;
    
    for(int i = 0 ; i < arr.size() ; i++){
        minHeap.push({arr[i] , i});
    }
    
    int lastEle= INT_MAX;
    int rank = 0;
    
    while(!minHeap.empty()){
        int curr = minHeap.top().first;
        int index = minHeap.top().second;
        minHeap.pop();
        
        if(lastEle == INT_MAX || lastEle != curr){
            rank++;
        }
        arr[index] = rank; 
        lastEle = curr;
    }
    
    return arr;
}
```

---

## 2) Top K Frequent Elements
ðŸ”— [Problem Link](https://leetcode.com/problems/top-k-frequent-elements)

### approach 1 (Min Heap with Frequency Map)
**Explanation:**
- Count frequency of each element using a hash map.
- Use a **min-heap** to store `(frequency, element)` pairs.
- Keep heap size at most `k`:
  - Push each `(count, num)` into heap.
  - If heap size exceeds `k`, pop the smallest frequency.
- At the end, heap contains the top k frequent elements.

**Steps:**
1. Create an unordered map `freq` to store element frequencies.
2. Iterate over `nums` and increment counts in `freq`.
3. Create a min-heap of pairs `(count, num)` with smallest frequency at the top.
4. Push each `(count, num)` into heap:
   - If heap size > `k`, pop from heap.
5. Extract elements from heap and store in a result vector.
6. Return the result vector.

**Time Complexity:** `O(n log k)`  
**Space Complexity:** `O(n)` (map + heap)

**Code:**
```cpp
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        unordered_map<int, int> freq;
        for (int num : nums) {
            freq[num]++;
        }

        // Min-heap to store the top k frequent elements
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;

        for (auto& [num, count] : freq) {
            pq.push({count, num});
            if (pq.size() > k) {
                pq.pop();
            }
        }

        vector<int> result;
        while (!pq.empty()) {
            result.push_back(pq.top().second);
            pq.pop();
        }

        return result;
    }
};
```
